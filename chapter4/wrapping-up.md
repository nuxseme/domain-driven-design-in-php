Some concepts in the domain demand identity, this is, mutations in their state don’t change them as a concept. We’ve seen how modeling identity as a Value Object brings some benefits like immutability and logic for operating the identity itself. We’ve shown several ways of providing identity:

* Persistence mechanism: Easy to implement but you’ll not have the identity before persisting the object, delaying and complicating event propagation.
* Surrogate id: Some ORMs require an extra field on your Entity to map the identity with the persisting mechanism Provided by the client: Sometimes the identity fits a domain concept and you could model it inside your domain.
* * Generated by the application: You could use a library to generate IDs.
* Generated by Bounded Context: Probably the most complex strategy. Other bounded context provides an interface for generating Identities.

We’ve seen and discussed Doctrine as a persistence mechanism, the drawbacks of using the Active Record pattern and finally we’ve checked different levels of Entity validation:

* Attribute validation: Check for specifics inside the object state through pre-conditions, post- conditions and invariants.
* Entire object validation: Looks for consistency of an object as a whole. Extracting the validation to an external service is a good practice.
* Object compositions: Complex object compositions could be validated through Domain Services. A good way of communicating this to the rest of the application is through Domain Events.



